<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>网红鸽子：UwU Funk 热舞挑战 - Designed by Laura</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #B0E2FF; 
            font-family: 'Arial Black', 'Microsoft YaHei', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        canvas {
            display: block;
            cursor: crosshair;
        }
        #ui-layer {
            position: absolute;
            top: 25px;
            pointer-events: none;
            text-align: center;
            width: 100%;
        }
        .score-box {
            display: inline-block;
            background: rgba(255, 255, 255, 0.95);
            padding: 10px 40px;
            border-radius: 50px;
            border: 4px solid #1e3799;
            box-shadow: 0 8px 20px rgba(0,0,0,0.2);
        }
        .score-text {
            font-size: 36px;
            font-weight: 900;
            color: #1e3799;
        }
        #footer {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: #1e3799;
            font-size: 18px;
            font-weight: bold;
            opacity: 0.8;
            pointer-events: none;
            text-shadow: 1px 1px 2px white;
        }
        #overlay {
            position: absolute;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            color: white;
            text-align: center;
        }
        #overlay h1 { font-size: 60px; margin-bottom: 20px; color: #FFD32A; text-shadow: 4px 4px #1e3799; }
        #start-btn {
            padding: 20px 60px;
            font-size: 32px;
            background: #2ecc71;
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 10px 0 #27ae60;
            transition: 0.1s;
        }
        #start-btn:active { transform: translateY(10px); box-shadow: 0 0 0 #27ae60; }
    </style>
</head>
<body>

    <div id="overlay">
        <h1>UWU FUNK PIGEON</h1>
        <p>跟着 UwU Funk 的节奏掠袭玉米！<br>连续吃到 3 次腐烂玉米可触发隐藏结局<br>分数为负将面临鸽子的终极嘲讽！</p>
        <button id="start-btn">开启 UwU 热舞</button>
    </div>

    <div id="ui-layer">
        <div class="score-box">
            <span class="score-text">SCORE: <span id="scoreVal">0</span></span>
        </div>
    </div>

    <div id="footer">Designed by Laura</div>

    <canvas id="gameCanvas"></canvas>

    <script>
        /** --- 音频引擎：UwU Funk 节奏同步 --- **/
        let audioCtx;
        let masterGain;
        let currentStep = 0;

        function initAudio() {
            if(audioCtx) return;
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            masterGain = audioCtx.createGain();
            masterGain.connect(audioCtx.destination);
            masterGain.gain.value = 0.4;
            playHyperFunk();
        }

        function playSound(freq, type, duration, vol = 0.3, slide = false) {
            if(!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const g = audioCtx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            if(slide) osc.frequency.exponentialRampToValueAtTime(freq * 0.4, audioCtx.currentTime + duration);
            g.gain.setValueAtTime(vol, audioCtx.currentTime);
            g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            osc.connect(g);
            g.connect(masterGain);
            osc.start();
            osc.stop(audioCtx.currentTime + duration);
        }

        // 定义失败音效
        function playLoudFailSound() {
            if(!audioCtx) return;
            for(let i=0; i<5; i++) {
                playSound(50 + i*15, 'sawtooth', 1.5, 0.9, true);
                playSound(30 + i*10, 'square', 1.2, 0.6, true);
            }
        }

        // 滑稽洪亮的中文配音
        function speakFail() {
            const utter = new SpeechSynthesisUtterance("你也太菜了");
            utter.lang = 'zh-CN';
            utter.pitch = 2.0; 
            utter.rate = 1.3;
            utter.volume = 1.0;
            window.speechSynthesis.speak(utter);
        }

        function playHyperFunk() {
            const bass = [73.42, 73.42, 98.00, 110.00, 116.54, 110.00, 98.00, 82.41]; 
            setInterval(() => {
                if(gameState === 'IDLE') return;

                if(currentStep % 4 === 0) {
                    playSound(bass[Math.floor(currentStep/4) % bass.length], 'triangle', 0.2, 0.7);
                    playSound(40, 'sine', 0.2, 0.9); 
                }
                if(currentStep % 8 === 4) playSound(200, 'sawtooth', 0.1, 0.3); 
                if(currentStep % 16 === 12) playSound(1400, 'square', 0.1, 0.1, true); 

                currentStep++;
            }, 120); 
        }

        /** --- 游戏核心逻辑 --- **/
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('scoreVal');
        const overlay = document.getElementById('overlay');
        const startBtn = document.getElementById('start-btn');

        let width, height;
        let score = 0;
        let rottenStreak = 0;
        let gameState = 'IDLE'; 
        let kernels = [];
        let windLines = [];

        const pigeon = {
            x: 0, y: 0,
            angle: 0,
            bankAngle: 0,
            z: 0,
            headBob: 0,
            wingPhase: 0,
            orbitAngle: 0,
            targetKernel: null,
            orbitRadius: 280,
            buttShake: 0
        };

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            initKernels();
        }

        function initKernels() {
            kernels = [];
            const centerX = width / 2;
            const centerY = height / 2;
            const totalCount = 16; 
            const rottenNum = 5;
            const wormNum = 3; 
            const rottenIndices = new Set();
            while(rottenIndices.size < rottenNum) rottenIndices.add(Math.floor(Math.random() * totalCount));
            
            const rottenArray = Array.from(rottenIndices);
            const wormIndices = new Set();
            while(wormIndices.size < Math.min(wormNum, rottenNum)) {
                wormIndices.add(rottenArray[Math.floor(Math.random() * rottenArray.length)]);
            }

            for(let i=0; i<totalCount; i++) {
                const angle = (i / totalCount) * Math.PI * 2;
                kernels.push({
                    x: centerX + Math.cos(angle) * 145,
                    y: centerY + Math.sin(angle) * 145,
                    angle: angle,
                    isRotten: rottenIndices.has(i),
                    hasWorm: wormIndices.has(i),
                    eaten: false,
                    wormOffset: Math.random() * 10
                });
            }
        }

        startBtn.onclick = () => {
            overlay.style.display = 'none';
            gameState = 'PLAY';
            initAudio();
        };

        window.addEventListener('resize', resize);
        resize();

        canvas.addEventListener('mousedown', () => {
            if(gameState === 'PLAY') {
                const available = kernels.filter(k => !k.eaten);
                if(available.length > 0) {
                    let closest = available[0];
                    let minDist = Math.hypot(closest.x - pigeon.x, closest.y - pigeon.y);
                    available.forEach(k => {
                        let d = Math.hypot(k.x - pigeon.x, k.y - pigeon.y);
                        if(d < minDist) { minDist = d; closest = k; }
                    });
                    pigeon.targetKernel = closest;
                    gameState = 'DIVE';
                    playSound(1000, 'sine', 0.2); 
                }
            } else if (['RESULT', 'FAIL', 'HIDDEN'].includes(gameState)) {
                score = 0; rottenStreak = 0; scoreEl.innerText = 0;
                initKernels(); gameState = 'PLAY';
            }
        });

        function drawFeatherTexture(ctx, x, y, size) {
            ctx.strokeStyle = 'rgba(0,0,0,0.06)'; ctx.lineWidth = 1;
            for(let i=0; i<3; i++) {
                ctx.beginPath(); ctx.arc(x - i*8, y + i*4, size/2.5, 0.5, Math.PI - 0.5); ctx.stroke();
            }
        }

        function drawPigeon(x, y, angle, state) {
            ctx.save();
            ctx.translate(x, y);
            
            const isDancing = (state === 'RESULT' || state === 'FAIL' || state === 'HIDDEN');
            const isDiving = state === 'DIVE';

            const COL_BLUE = "#3b67bf";
            const COL_CHEST = "#8ab1ff";
            const COL_NECK = "#8e44ad";
            const COL_WINGS = "#ecf0f1";
            const COL_LEG = "#ff7979";

            if(isDancing) {
                const beat = currentStep % 4;
                const bounce = (beat === 0 ? 50 : 0); 
                const shake = Math.sin(currentStep * 0.9) * (state === 'HIDDEN' ? 100 : 60); 
                
                if(state === 'HIDDEN') ctx.scale(1.6, 1.6); 

                ctx.translate(0, -bounce);
                ctx.fillStyle = 'rgba(0,0,0,0.1)';
                ctx.beginPath(); ctx.ellipse(0, 130 + bounce, 75, 18, 0, 0, Math.PI*2); ctx.fill();

                ctx.strokeStyle = COL_LEG; ctx.lineWidth = 3;
                ctx.beginPath(); ctx.moveTo(-20, 50); ctx.lineTo(-25, 130); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(20, 50); ctx.lineTo(25, 130); ctx.stroke();

                ctx.fillStyle = COL_BLUE;
                ctx.beginPath(); ctx.ellipse(shake, 20, 85, 75, 0, 0, Math.PI * 2); ctx.fill();
                drawFeatherTexture(ctx, shake, 20, 80);

                ctx.fillStyle = COL_BLUE;
                ctx.beginPath(); ctx.ellipse(0, 5, 62, 78, 0, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = COL_CHEST;
                ctx.beginPath(); ctx.ellipse(0, 15, 42, 52, 0, 0, Math.PI * 2); ctx.fill();

                ctx.fillStyle = COL_NECK;
                ctx.beginPath(); ctx.ellipse(0, -65, 32, 45, 0, 0, Math.PI * 2); ctx.fill();

                ctx.fillStyle = COL_BLUE;
                ctx.beginPath(); ctx.arc(0, -110, 35, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#f39c12';
                ctx.beginPath(); ctx.arc(-16, -118, 12, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(16, -118, 12, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = 'black';
                const eyeTremor = Math.sin(currentStep * 1.5) * (state === 'FAIL' ? 8 : 3);
                ctx.beginPath(); ctx.arc(-16 + eyeTremor, -118, 6, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(16 + eyeTremor, -118, 6, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = '#f1c40f';
                ctx.beginPath(); ctx.moveTo(-8, -102); ctx.lineTo(0, -82); ctx.lineTo(8, -102); ctx.fill();

            } else {
                ctx.scale(1 + pigeon.z * 0.5, 1 + pigeon.z * 0.5);
                ctx.rotate(angle);
                if (isDiving) ctx.rotate(Math.PI/2); else ctx.rotate(pigeon.bankAngle);

                ctx.save();
                if(!isDiving) ctx.rotate(-angle - pigeon.bankAngle); else ctx.rotate(-angle - Math.PI/2);
                ctx.fillStyle = `rgba(0,0,0,${0.2 - pigeon.z*0.1})`;
                ctx.beginPath(); ctx.ellipse(0, 95 + pigeon.z*30, 75, 18, 0, 0, Math.PI*2); ctx.fill();
                ctx.restore();

                ctx.strokeStyle = COL_LEG; ctx.lineWidth = 2.5;
                ctx.beginPath(); ctx.moveTo(0, 15); ctx.lineTo(-12, 38); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(12, 15); ctx.lineTo(12, 38); ctx.stroke();

                ctx.fillStyle = COL_BLUE;
                ctx.beginPath(); ctx.ellipse(-45, 8, 78, 62, 0, 0, Math.PI * 2); ctx.fill();

                ctx.save(); ctx.translate(0, -35); ctx.fillStyle = COL_WINGS;
                const flap = Math.sin(pigeon.wingPhase);
                [-1, 1].forEach(s => {
                    ctx.save(); ctx.scale(1, s); ctx.rotate(flap * (isDiving?1.4:0.6));
                    ctx.beginPath(); ctx.moveTo(0,0); ctx.bezierCurveTo(-25,-90,-130,-70,-80,25); ctx.fill();
                    ctx.restore();
                });
                ctx.restore();

                const bodyGrad = ctx.createRadialGradient(0,0,5,0,0,85);
                bodyGrad.addColorStop(0, COL_CHEST); bodyGrad.addColorStop(1, COL_BLUE);
                ctx.fillStyle = bodyGrad;
                ctx.beginPath(); ctx.ellipse(25, 5, 68, 52, 0, 0, Math.PI * 2); ctx.fill();

                ctx.save(); ctx.translate(65 + pigeon.headBob, -15);
                ctx.fillStyle = COL_NECK;
                ctx.beginPath(); ctx.ellipse(0, 0, 28, 42, 0.3, 0, Math.PI * 2); ctx.fill();

                ctx.fillStyle = COL_BLUE;
                ctx.beginPath(); ctx.arc(15, -30, 30, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#f39c12'; ctx.beginPath(); ctx.arc(35,-38,13,0,Math.PI*2); ctx.fill();
                ctx.fillStyle = 'black'; ctx.beginPath(); ctx.arc(38,-38,7,0,Math.PI*2); ctx.fill();
                ctx.fillStyle = '#f1c40f'; ctx.beginPath(); ctx.moveTo(45,-30); ctx.lineTo(80,-25); ctx.lineTo(45,-20); ctx.fill();
                ctx.restore();
            }
            ctx.restore();
        }

        function drawCorn() {
            const cx = width / 2, cy = height / 2;
            ctx.save();
            const g = ctx.createRadialGradient(cx, cy, 5, cx, cy, 125);
            g.addColorStop(0, '#FFFBE6'); g.addColorStop(0.2, '#FFF59D'); g.addColorStop(0.85, '#FBC02D'); g.addColorStop(1, '#8D6E63'); 
            ctx.fillStyle = g;
            ctx.beginPath(); ctx.arc(cx, cy, 120, 0, Math.PI*2); ctx.fill();
            ctx.strokeStyle = 'rgba(139, 69, 19, 0.15)'; ctx.lineWidth = 1.2;
            for(let i=0; i<60; i++) {
                const a = (i/60)*Math.PI*2;
                const r1 = 15 + Math.random()*25; const r2 = 80 + Math.random()*35;
                ctx.beginPath(); ctx.moveTo(cx+Math.cos(a)*r1, cy+Math.sin(a)*r1); ctx.lineTo(cx+Math.cos(a)*r2, cy+Math.sin(a)*r2); ctx.stroke();
            }
            ctx.restore();

            kernels.forEach(k => {
                if(!k.eaten) {
                    ctx.save(); ctx.translate(k.x, k.y); ctx.rotate(k.angle + Math.PI/2);
                    if(k.isRotten) ctx.fillStyle = '#3E2723';
                    else {
                        const kg = ctx.createRadialGradient(-8, -15, 3, 0, 0, 32);
                        kg.addColorStop(0, '#FFFFFF'); kg.addColorStop(1, '#FBC02D'); ctx.fillStyle = kg;
                    }
                    ctx.beginPath(); ctx.ellipse(0, 0, 28, 38, 0, 0, Math.PI*2); ctx.fill();
                    
                    if(k.hasWorm && k.isRotten) {
                        ctx.fillStyle = 'rgba(0,0,0,0.6)';
                        ctx.beginPath(); ctx.ellipse(0, 5, 15, 15, 0, 0, Math.PI*2); ctx.fill(); 
                        ctx.save();
                        const ws = Math.sin(Date.now()*0.012 + k.wormOffset) * 15 - 5;
                        ctx.fillStyle = '#7bed9f';
                        for(let i=0; i<3; i++) {
                            const segY = ws + i*10;
                            if(segY < 12) { ctx.beginPath(); ctx.arc(-6 + i*6, segY, 8, 0, Math.PI*2); ctx.fill(); }
                        }
                        ctx.fillStyle = 'white'; ctx.beginPath(); ctx.arc(6, ws-5, 3.5, 0, Math.PI*2); ctx.fill();
                        ctx.fillStyle = 'black'; ctx.beginPath(); ctx.arc(7, ws-5, 1.5, 0, Math.PI*2); ctx.fill();
                        ctx.restore();
                    }
                    ctx.restore();
                }
            });
        }

        function update() {
            if(gameState === 'PLAY') {
                pigeon.z *= 0.88; 
                pigeon.orbitAngle += 0.028; pigeon.bankAngle = 0.22;
                const tx = width/2 + Math.cos(pigeon.orbitAngle) * pigeon.orbitRadius;
                const ty = height/2 + Math.sin(pigeon.orbitAngle) * pigeon.orbitRadius;
                pigeon.x += (tx - pigeon.x) * 0.2; pigeon.y += (ty - pigeon.y) * 0.2;
                pigeon.angle = Math.atan2(ty - pigeon.y, tx - pigeon.x);
                pigeon.headBob = Math.sin(Date.now() * 0.01) * 10; pigeon.wingPhase += 0.35;
            } 
            else if(gameState === 'DIVE') {
                const k = pigeon.targetKernel;
                const dx = k.x - pigeon.x, dy = k.y - pigeon.y;
                const dist = Math.hypot(dx, dy);
                pigeon.z = Math.min(1, pigeon.z + 0.15); 
                pigeon.angle = Math.atan2(dy, dx);
                pigeon.wingPhase += 1.5; 

                if(dist > 25) { pigeon.x += dx * 0.45; pigeon.y += dy * 0.45; } 
                else {
                    k.eaten = true;
                    if(k.isRotten || k.hasWorm) { 
                        score -= (k.hasWorm ? 2 : 1); 
                        rottenStreak++;
                        playSound(80, 'triangle', 0.8); 
                        if(rottenStreak >= 3 && score >= 0) { gameState = 'HIDDEN'; return; }
                    } else { 
                        score += 1; rottenStreak = 0; playSound(1400, 'sine', 0.15); 
                    }
                    scoreEl.innerText = score;
                    if(score < 0) {
                        gameState = 'FAIL';
                        playLoudFailSound();
                        speakFail();
                    } else {
                        if(kernels.filter(k => !k.isRotten && !k.hasWorm && !k.eaten).length === 0) gameState = 'RESULT';
                        else gameState = 'PLAY';
                    }
                }
            } else if (['RESULT', 'FAIL', 'HIDDEN'].includes(gameState)) {
                pigeon.x = width/2; pigeon.y = height/2 + 200;
            }
        }

        function drawResult() {
            ctx.save();
            if(gameState === 'HIDDEN') {
                ctx.fillStyle = `hsla(${Date.now()%360}, 70%, 50%, 0.3)`;
                ctx.fillRect(0,0,width,height);
            }

            ctx.fillStyle = 'rgba(255,255,255,0.98)';
            ctx.shadowBlur = 40; ctx.shadowColor = 'rgba(0,0,0,0.3)';
            const panelY = height/2 - 380; 
            const shakeUI = (gameState === 'FAIL' || gameState === 'HIDDEN' ? Math.sin(Date.now()*0.1)*12 : 0);
            ctx.beginPath(); ctx.roundRect(width/2 - 300 + shakeUI, panelY, 600, 300, 40); ctx.fill();
            
            ctx.textAlign = 'center';
            if(gameState === 'RESULT') {
                ctx.fillStyle = '#1e3799';
                ctx.font = "900 52px Arial"; ctx.fillText("热舞霸主诞生!", width/2 + shakeUI, panelY + 100);
                ctx.fillStyle = '#2ecc71';
                ctx.font = "bold 90px Arial"; ctx.fillText(`${score}`, width/2 + shakeUI, panelY + 200);
            } else if(gameState === 'FAIL') {
                ctx.fillStyle = '#c0392b';
                ctx.font = "900 100px 'Microsoft YaHei'"; 
                ctx.fillText("你也太菜了!", width/2 + shakeUI, panelY + 130);
                ctx.fillStyle = '#FF4757';
                ctx.font = "bold 80px Arial"; ctx.fillText(`${score}`, width/2 + shakeUI, panelY + 230);
            } else if(gameState === 'HIDDEN') {
                ctx.fillStyle = '#8e44ad';
                ctx.font = "900 65px Arial"; ctx.fillText("腐烂之王诞生!", width/2 + shakeUI, panelY + 110);
                ctx.fillStyle = '#f39c12';
                ctx.font = "bold 45px Arial"; ctx.fillText("运气也是实力的一种!", width/2 + shakeUI, panelY + 200);
            }
            ctx.font = "24px Arial"; ctx.fillStyle = '#7f8c8d'; 
            ctx.fillText("点击任何位置重启 Funk 挑战", width/2 + shakeUI, panelY + 275);
            ctx.restore();
        }

        function loop() {
            ctx.clearRect(0, 0, width, height);
            drawCorn();
            update();
            drawPigeon(pigeon.x, pigeon.y, pigeon.angle, gameState);
            if(['RESULT', 'FAIL', 'HIDDEN'].includes(gameState)) drawResult();
            requestAnimationFrame(loop);
        }

        loop();
    </script>
</body>
</html>
